#include "opencv2/opencv.hpp"
#include "stdio.h"
using namespace cv;
using namespace std;

# define G_NUM_BACKGROUND 2//5 最大63帧
# define G_YUZHI 20
typedef struct tagSIZE
{
	int x;
	int y;
} ROI_SIZE;

ROI_SIZE ROI = { 200, 100 };
Rect Rect_1;
RotatedRect Rect_2;
int main()
{
	Mat frame, frame_2, frame_3, gray_image, roi_image, rimage, f_image, gray_image_p, gray_image_threshold;
	Mat background, background_1, background_2, background_3, background_result_1, background_result_2;
	//IplImage  *background_result_11, *background_result_22;//
	vector<Mat>  roi_image_channels;
	vector<vector<Point>> contours;
	vector<Point> maxcontours;
	unsigned int maxnum = 0;
	int num_frame_1 = 1;

	double fps;
	double t;
	char str[50];

	Point Goal;

	int key;

	char filename[100];
	int g_n1=1, g_n2, g_n3, k = 0;



	namedWindow("原图", 0);
	namedWindow("处理区域", 0);
	namedWindow("结果", 0);
	namedWindow("相减后", 0);
	/*namedWindow("膨胀后", 0);*/
	//namedWindow("当前ROI原图二值化图", 0);
	namedWindow("background_result_2", 0);
	/*namedWindow("background_2", 0);
	namedWindow("background_3", 0);*/
	//VideoCapture capture(0);
	//background_1, background_2, background_3;
	VideoCapture capture("G:/学习2/2017-1-17-免驱摄像头图像目录/2017-1-17-capture-/2017-0214-19-46-04.avi");//G:/学习2/2016-10-2-OPENCV/2017-1-15-张迎港资料/一些素材/12.3/WIN_20161203_00_45_14_Pro   WIN_20161203_00_52_00_Pro Video_2017-02-15_194658.wmv
	//t = (double)getTickCount();

	for (int i = 0; i < G_NUM_BACKGROUND; i++)
	{
		capture >> frame;
		if (frame.empty())
		{
			printf("\n无信号输入\n");
			break;
		}
		g_n1 = ( - g_n1);
		roi_image = frame(Rect(200 + g_n1, 300+g_n1, ROI.x, ROI.y));//注意两个Rect一定要相等 (Rect(200, 300, ROI.x, ROI.y)) 
		if (background_result_2.empty())
		{
			/*cvCreateImage(roi_image.size, roi_image.depth, roi_image.Channels);*/
			background_result_2.create(roi_image.rows, roi_image.cols, CV_8UC1);
			background_result_2.operator = (0);
			//background_result_22 = &(background_result_2.operator IplImage());
		}
		cvtColor(roi_image, gray_image, CV_BGR2GRAY);
		if (background_1.empty())
		{
			gray_image.copyTo(background_1);
		}
		absdiff(background_1, gray_image, background_result_1);//		帧差法关键步骤
		gray_image.copyTo(background_1);
		imshow("背景相减后", background_result_1);
		//background_result_11 = &(background_result_1.operator IplImage());
		//cvShowImage("background_result_11", background_result_11);
	
		/*background_result_1.copyTo(background_result_2);*/
		//cvAdd(background_result_11, background_result_22, background_result_22);
		
		addWeighted(background_result_1, 1, background_result_2,
			1, 0, background_result_2);
		//morphologyEx(background_result_2, background_result_2, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(3, 3)));//膨胀  

		

		/*capture >> background_1;
		capture >> background_2;
		capture >> background_3;
		imshow("background_1",background_1);
		imshow("background_2", background_2);
		imshow("background_3", background_3);*/
	}
	threshold(background_result_2, background_result_2, 50, 255, THRESH_BINARY);//将差值进行二值化。
	imshow("background_result_2", background_result_2);
	imwrite("1.bmp" , background_result_2);
	//t = ((double)getTickCount() - t) / getTickFrequency();
	//cvtColor(roi_image, gray_image, CV_BGR2GRAY);
	//*************************************************************************
	for (;;)
	{
		t = (double)getTickCount();
		//frame, frame_2, frame_3
		capture >> frame;
		/*capture >> frame_2;
		capture >> frame_3;*/
		if (frame.empty())
		{
			printf("\n无信号输入\n");
			break;
		}
		//此处是静态的、固定的ROI,后续最好可以实现动态的、自动的ROI锁定 ROI.x, ROI.y 代表宽度和高度
		roi_image = frame(Rect(200, 300, ROI.x, ROI.y));//(Rect(100, 150, ROI.x, ROI.y)) (Rect(100, 100, ROI.x, ROI.y))
		//将截取的ROI彩色通道分离 彩色空间为BGR 蓝 绿 红 
		split(roi_image, roi_image_channels);
		/*roi_image = frame_2(Rect(170, 150, ROI.x, ROI.y));
		roi_image = frame_3(Rect(170, 150, ROI.x, ROI.y));*/
		cvtColor(roi_image, gray_image, CV_BGR2GRAY);

		if (background.empty())
		{
			gray_image.copyTo(background);
		}
		//由于相机拍摄的噪声主要是高斯分布，所以采用高斯滤波。
		//GaussianBlur(gray_image, gray_image, Size(3, 3), 0, 0);

		//morphologyEx(background, background, MORPH_ERODE, getStructuringElement(MORPH_RECT, Size(5, 5)));//腐蚀
		//morphologyEx(background, background, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  

		//gray_image-background的灰度图）的绝对值
		absdiff(background, gray_image, rimage);//		帧差法关键步骤
		// 对得到的前景进行阈值选取，去掉伪前景


		threshold(rimage, rimage, 30, 255, THRESH_BINARY);//将差值进行二值化。
		imshow("帧差后", rimage);
		/*imshow("相减后1", rimage);*/
		//遍历各个像素，将由于抖动的背景轮廓去除，结合彩色信息还原飞盘像素点  一个关键步骤
		////background_result_2  rimage   G_YUZHI
		//t = (double)getTickCount();  roi_image.at<Vec3b>(i, j)[0]
		k = 0;
		//jj = 0;
		for (int i = 0; i < rimage.rows; i++)
		{
			uchar* rimage_data = rimage.ptr<uchar>(i);//此时rimage已经二值化
			uchar* background_result_2_data = background_result_2.ptr<uchar>(i);

			uchar* roi_image_data_red = roi_image_channels[2].ptr<uchar>(i);
			uchar* roi_image_data_green = roi_image_channels[1].ptr<uchar>(i);
			uchar* roi_image_data_blue = roi_image_channels[0].ptr<uchar>(i);

			for (int j = 0; j < rimage.cols; j++)
			{
				if (
					//(rimage.at<char>(i, j) == background_result_2.at<char>(i, j)) 
					(rimage_data[j] >= 225) && (background_result_2_data[j] >= 225)
					
					)

					//rimage.at<char>(i, j) = 0;
				{
					/*int red = roi_image.at<Vec3b>(i, j)[2];
					int green = roi_image.at<Vec3b>(i, j)[1];
					int blue = roi_image.at<Vec3b>(i, j)[0];*/
					/*if (
					red>(green * 2) && red > (blue * 2 && red>50)
					)

					{
					rimage_data[j] = 255;
					jj++;
					cout << red << endl;

					}*/
					if (roi_image_data_red[j]>(roi_image_data_green[j] * 2) && roi_image_data_red[j]>(roi_image_data_blue[j] * 2) && roi_image_data_red[j]>40)
					{
						rimage_data[j] = 255;
						//jj++;
						//cout << (int)roi_image_data_red[j] << endl;

					}
					else
						rimage_data[j] = 0;
				}
				if (
					//(rimage.at<char>(i, j) - background_result_2.at<char>(i, j))>G_YUZHI
					(rimage_data[j] - background_result_2_data[j])>G_YUZHI
					)
					//rimage.at<char>(i, j) = 255;
					rimage_data[j] = 255;
				k++;
			}

		}
		cout << k << endl;
		t = ((double)getTickCount() - t) / getTickFrequency();
		imshow("相减后", rimage);

		/*imshow("红色通道", roi_image_channels[2]);
		imshow("绿色通道", roi_image_channels[1]);
		imshow("蓝色通道", roi_image_channels[0]);*/

		//将当前灰度图二值化
		//threshold(gray_image, gray_image_threshold, 30, 255, THRESH_BINARY);//将差值进行二值化。
		//imshow("当前ROI原图二值化图", gray_image_threshold);

		//注释掉即为背景侦察法。不注释就是帧差法。
		//gray_image.copyTo(background);

		// 看膨胀后的效果
		//morphologyEx(rimage, gray_image_p, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(3, 3)));//膨胀  
		//imshow("膨胀后", gray_image_p);


		//开运算
		//morphologyEx(rimage, rimage, MORPH_ERODE, getStructuringElement(MORPH_RECT, Size(3, 3)));//腐蚀
		//morphologyEx(rimage, rimage, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  
		morphologyEx(rimage, rimage, MORPH_OPEN, getStructuringElement(MORPH_RECT, Size(5, 5)));//MORPH_DILATE MORPH_ERODE 5
		//morphologyEx(rimage, rimage, MORPH_CLOSE, getStructuringElement(MORPH_RECT, Size(5, 5)));//MORPH_DILATE MORPH_ERODE
		morphologyEx(rimage, rimage, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  

		rimage.copyTo(f_image);
		findContours(f_image, contours, CV_RETR_EXTERNAL, CHAIN_APPROX_NONE, Point(0, 0));


		cout << "第" << num_frame_1 << "张图" << "找到" << contours.size() << "个轮廓" << endl;
		//筛选出最大的轮廓addWeighted

		for (int i = 0; i < contours.size(); i++)
		{
			if (contours[i].size()> maxcontours.size())
			{
				maxnum = i;
				maxcontours = contours[i];
			}
		}
		//用冒泡法进行排序
		/*for (int i = 0; i < maxcontours.size(); i++)
		{
		for (int j = i; j < maxcontours.size(); j++)
		{
		if (maxcontours[j].x>maxcontours[i].x)
		{
		int temp_value_x = maxcontours[i].x;
		maxcontours[j].x = maxcontours[i].x;
		maxcontours[i].x = temp_value_x;
		}
		if (maxcontours[j].y>maxcontours[i].y)
		{
		int temp_value_y = maxcontours[i].y;
		maxcontours[j].y = maxcontours[i].y;
		maxcontours[i].y = temp_value_y;
		}
		}
		}*/
		/*for (int ii = 0; ii < maxcontours.size(); ii++)
		{
		for (int jj = ii; jj < maxcontours.size(); jj++)
		{
		if (maxcontours[jj].x>maxcontours[ii].x)
		{
		int temp_value_x = maxcontours[ii].x;
		maxcontours[jj].x = maxcontours[ii].x;
		maxcontours[ii].x = temp_value_x;
		}
		if (maxcontours[jj].y>maxcontours[ii].y)
		{
		int temp_value_y = maxcontours[ii].y;
		maxcontours[jj].y = maxcontours[ii].y;
		maxcontours[ii].y = temp_value_y;
		}
		}
		}*/
		//CvRect rect = cvBoundingRect(maxcontours, 0);

		/*if (maxcontours.size() != 0)
		{
		Rect_1 = boundingRect(maxcontours);
		Rect_2 = fitEllipse(maxcontours);
		rectangle(roi_image, Rect_1, Scalar(0, 0, 255), 1, 8);
		ellipse(roi_image, Rect_2, Scalar(0, 0, 255), 1, 8);
		}*/

		/*void rectangle(CV_IN_OUT Mat& img, Rect rec,
		const Scalar& color, int thickness = 1,
		int lineType = 8, int shift = 0);*/
		for (int i = 0; i < maxcontours.size(); i++)
		{
			//cout << maxcontours[i].x<< endl;
			Goal.x += maxcontours[i].x;
			Goal.y += maxcontours[i].y;

		}
		if (maxcontours.size() > 50)
		{
			cout << maxcontours.size() << endl;
			Goal.x /= maxcontours.size();
			Goal.y /= maxcontours.size();
			cout << "目标点的坐标为" << "X:" << Goal.x << "Y:" << Goal.y << endl;
			circle(roi_image, Goal, 50, Scalar(0, 0, 255), 5, 8);
		}
		else
		{
			cout << "未发现目标点" << endl;
		}




		num_frame_1++;

		//变量复位。
		Goal = { 0, 0 };
		maxnum = 0;
		maxcontours.clear();
		//显示帧率
		//t = ((double)getTickCount() - t) / getTickFrequency();
		fps = 1.0 / t;
		sprintf_s(str, "FPS:%5f", fps);
		putText(frame, str, Point(0, 30), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 255));

		imshow("原图", frame);
		imshow("处理区域", roi_image);
		imshow("结果", rimage);


		key = waitKey(30);

		//switch (key)
		//{
		//case 'c':	sprintf_s(filename, "%d.bmp", num_frame_1);//G:\学习2\2016-10-2-OPENCV\2017-1-15-张迎港资料\动态检测\程序\侦差法\zhen_cha   //G:/学习2/2016-10-2-OPENCV/2017-1-15-张迎港资料/动态检测/程序/侦差法/zhen_cha/
		//			imwrite(filename, roi_image);
		//			printf("第%d采集完成\n",num_frame_1);
		//			break;
		//}
		//if (key==65)
		//	break;

	}
}



