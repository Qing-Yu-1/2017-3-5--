#include "opencv2/opencv.hpp"
#include "stdio.h"
using namespace cv;
using namespace std;

# define G_NUM_BACKGROUND 5//5 最大63帧
# define G_YUZHI 20
typedef struct tagSIZE
{
	int x;
	int y;
} ROI_SIZE;

ROI_SIZE ROI = { 400, 175 };//   200, 100
Rect Rect_ROI(100, 150, ROI.x, ROI.y);
Rect Rect_1;
RotatedRect Rect_2;
int biaoding_flag = 0;
void on_MouseHandle(int event, int x, int y, int flags, void* param);
int main()
{
	Mat frame, frame_2, frame_3, gray_image, roi_image, rimage, f_image, gray_image_p, gray_image_threshold;
	Mat background, background_1, background_2, background_3, background_result_1, background_result_2;
	Mat histogramImage;//用来显示投影
	//IplImage  *background_result_11, *background_result_22;//
	vector<Mat>  roi_image_channels;
	vector<vector<Point>> contours;
	vector<Point> maxcontours;
	unsigned int maxnum = 0;
	int num_frame_1 = 1;

	double fps;
	double t;
	char str[50];

	Point Goal;

	int key;

	char filename[100];
	int g_n1 = 1, g_n2, g_n3, k = 0;
	//int g_ColHeight[500] = { 0 };// 统计高度的数组指针
	int *g_ColHeight = new int[500];
	//memset(g_ColHeight, 0, background_result_1.cols * 4);
	int g_ColHeightLong = 0;//统计投影长度
	

	namedWindow("原图", 0);
	namedWindow("处理区域", 0);
	namedWindow("结果", 0);
	namedWindow("相减后", 0);
	/*namedWindow("膨胀后", 0);*/
	//namedWindow("当前ROI原图二值化图", 0);
	namedWindow("background_result_2", 0);
	/*namedWindow("background_2", 0);
	namedWindow("background_3", 0);*/
	//VideoCapture capture(0);
	//background_1, background_2, background_3;
	//"G:/学习2/2017-1-17-免驱摄像头图像目录/2017-1-17-capture-/2017-0214-19-46-04.avi"
	VideoCapture capture("G://学习2//2016-10-2-OPENCV//2017-1-15-张迎港资料//一些素材//12.3//WIN_20161203_00_52_00_Pro.mp4");//G:/学习2/2016-10-2-OPENCV/2017-1-15-张迎港资料/一些素材/12.3/WIN_20161203_00_45_14_Pro   WIN_20161203_00_52_00_Pro Video_2017-02-15_194658.wmv
	//t = (double)getTickCount();
	//VideoCapture capture(1);
	setMouseCallback("原图", on_MouseHandle, (void*)&frame);
	
	while (1)
	{
		capture >> frame;
		key = waitKey(1000);
		switch (key)
		{
		case 'b': biaoding_flag = !biaoding_flag; break;
		}
		
		rectangle(frame, Rect_ROI, Scalar(0, 255, 255), 2, 5);
		imshow("原图", frame);
		if (biaoding_flag == 1)
		{	
			cout << "ROI选取成功！";
			break;
		}
	}
	for (int i = 0; i < G_NUM_BACKGROUND; i++)
	{
		capture >> frame;
		if (frame.empty())
		{
			printf("\n无信号输入\n");
			break;
		}
		//
		roi_image = frame(Rect_ROI);//注意3个Rect一定要相等 Rect(200 , 300 , ROI.x, ROI.y) Rect_ROI
		if (background_result_2.empty())
		{
			/*cvCreateImage(roi_image.size, roi_image.depth, roi_image.Channels);*/
			background_result_2.create(roi_image.rows, roi_image.cols, CV_8UC1);
			background_result_2.operator = (0);
			//background_result_22 = &(background_result_2.operator IplImage());
		}
		cvtColor(roi_image, gray_image, CV_BGR2GRAY);
		if (background_1.empty())
		{
			gray_image.copyTo(background_1);
		}
		if (i == 0) continue;//结束本次循环
		absdiff(background_1, gray_image, background_result_1);//		帧差法关键步骤
		gray_image.copyTo(background_1);
		imshow("背景相减后", background_result_1);

		//background_result_11 = &(background_result_1.operator IplImage());
		//cvShowImage("background_result_11", background_result_11);

		//将background_result_1进行水平投影
		//给指针g_ColHeight指向的数组指定大小
		/*if (i = 0)
		{
		g_ColHeight = new int[background_result_1.cols];
		}*/
		//数组清零 
		memset(g_ColHeight, 0, background_result_1.cols * 4);
		int value;
		for (int i = 0; i < background_result_1.rows; i++)
		{
			for (int j = 0; j < background_result_1.cols; j++)
			{
				value = background_result_1.at<uchar>(i, j);
				if (value > 50)
				{
					g_ColHeight[j]++;//统计每列的白色像素点   
				}
			}
		}
		//将histogramImage赋初值
		if (histogramImage.empty())
		{
			histogramImage.create(background_result_1.rows, background_result_1.cols, CV_8UC1);
		}
		histogramImage.operator = (0);
		for (int i = 0; i < histogramImage.cols; i++)
		{

			for (int j = 0; j < g_ColHeight[i]; j++)//
			{

				histogramImage.at<uchar>(j, i) = 255;//设置为白色
			}
		}
		imshow("水平投影图", histogramImage);
		g_ColHeightLong = 0;// 清零
		//统计g_ColHeight的长度
		for (int j = 0; j < background_result_1.cols; j++)
		{
			if (g_ColHeight[j]>8)
			{
				g_ColHeightLong++;
			}
		}
		cout << "投影长度" << g_ColHeightLong << endl;
		/*background_result_1.copyTo(background_result_2);*/
		//cvAdd(background_result_11, background_result_22, background_result_22);
		if (g_ColHeightLong > background_result_1.cols / 2)//
		{
			addWeighted(background_result_1, 1, background_result_2,
				1, 0, background_result_2);
		}
		else
		{
			cout << "jingru";
			g_n1 = (-g_n1);
			roi_image = frame(Rect(Rect_ROI.x + g_n1, Rect_ROI.y + g_n1, ROI.x, ROI.y));//Rect(100, 150, ROI.x, ROI.y)  Rect_ROI
			cvtColor(roi_image, gray_image, CV_BGR2GRAY);
			absdiff(background_1, gray_image, background_result_1);//		帧差法关键步骤
			imshow("背景相减后", background_result_1);
			addWeighted(background_result_1, 1, background_result_2,
				1, 0, background_result_2);
		}

		//morphologyEx(background_result_2, background_result_2, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(3, 3)));//膨胀  



		/*capture >> background_1;
		capture >> background_2;
		capture >> background_3;
		imshow("background_1",background_1);
		imshow("background_2", background_2);
		imshow("background_3", background_3);*/
	}
	threshold(background_result_2, background_result_2, 50, 255, THRESH_BINARY);//将差值进行二值化。
	imshow("background_result_2", background_result_2);
	//imwrite("1.bmp" , background_result_2);
	//t = ((double)getTickCount() - t) / getTickFrequency();
	//cvtColor(roi_image, gray_image, CV_BGR2GRAY);
	//*************************************************************************
	for (;;)
	{
		t = (double)getTickCount();
		//frame, frame_2, frame_3
		capture >> frame;
		/*capture >> frame_2;
		capture >> frame_3;*/
		if (frame.empty())
		{
			printf("\n无信号输入\n");
			break;
		}
		//此处是静态的、固定的ROI,后续最好可以实现动态的、自动的ROI锁定 ROI.x, ROI.y 代表宽度和高度
		roi_image = frame(Rect_ROI);//(Rect(100, 150, ROI.x, ROI.y)) (Rect(100, 100, ROI.x, ROI.y)) Rect_ROI
		//将截取的ROI彩色通道分离 彩色空间为BGR 蓝 绿 红 
		split(roi_image, roi_image_channels);
		/*roi_image = frame_2(Rect(170, 150, ROI.x, ROI.y));
		roi_image = frame_3(Rect(170, 150, ROI.x, ROI.y));*/
		cvtColor(roi_image, gray_image, CV_BGR2GRAY);

		if (background.empty())
		{
			gray_image.copyTo(background);
		}
		//由于相机拍摄的噪声主要是高斯分布，所以采用高斯滤波。
		//GaussianBlur(gray_image, gray_image, Size(3, 3), 0, 0);

		//morphologyEx(background, background, MORPH_ERODE, getStructuringElement(MORPH_RECT, Size(5, 5)));//腐蚀
		//morphologyEx(background, background, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  

		//gray_image-background的灰度图）的绝对值
		absdiff(background, gray_image, rimage);//		帧差法关键步骤
		// 对得到的前景进行阈值选取，去掉伪前景


		threshold(rimage, rimage, 15, 255, THRESH_BINARY);//将差值进行二值化。
		imshow("帧差后", rimage);
		/*imshow("相减后1", rimage);*/
		//遍历各个像素，将由于抖动的背景轮廓去除，结合彩色信息还原飞盘像素点  一个关键步骤
		////background_result_2  rimage   G_YUZHI
		//t = (double)getTickCount();  roi_image.at<Vec3b>(i, j)[0]
		k = 0;
		//jj = 0;
		for (int i = 0; i < rimage.rows; i++)
		{
			uchar* rimage_data = rimage.ptr<uchar>(i);//此时rimage已经二值化
			uchar* background_result_2_data = background_result_2.ptr<uchar>(i);

			uchar* roi_image_data_red = roi_image_channels[2].ptr<uchar>(i);
			uchar* roi_image_data_green = roi_image_channels[1].ptr<uchar>(i);
			uchar* roi_image_data_blue = roi_image_channels[0].ptr<uchar>(i);

			for (int j = 0; j < rimage.cols; j++)
			{
				if (
					//(rimage.at<char>(i, j) == background_result_2.at<char>(i, j)) 
					(rimage_data[j] >= 225) && (background_result_2_data[j] >= 225)

					)

					//rimage.at<char>(i, j) = 0;
				{
					/*int red = roi_image.at<Vec3b>(i, j)[2];
					int green = roi_image.at<Vec3b>(i, j)[1];
					int blue = roi_image.at<Vec3b>(i, j)[0];*/
					/*if (
					red>(green * 2) && red > (blue * 2 && red>50)
					)

					{
					rimage_data[j] = 255;
					jj++;
					cout << red << endl;

					}*/
					if (roi_image_data_red[j]>(roi_image_data_green[j] * 2) && roi_image_data_red[j]>(roi_image_data_blue[j] * 2) && roi_image_data_red[j]>40)
					{
						rimage_data[j] = 255;
						//jj++;
						//cout << (int)roi_image_data_red[j] << endl;

					}
					else
						rimage_data[j] = 0;
				}
				if (
					//(rimage.at<char>(i, j) - background_result_2.at<char>(i, j))>G_YUZHI
					(rimage_data[j] - background_result_2_data[j])>G_YUZHI
					)
					//rimage.at<char>(i, j) = 255;
					rimage_data[j] = 255;
				k++;
			}

		}
		cout << k << endl;
		t = ((double)getTickCount() - t) / getTickFrequency();
		imshow("相减后", rimage);

		/*imshow("红色通道", roi_image_channels[2]);
		imshow("绿色通道", roi_image_channels[1]);
		imshow("蓝色通道", roi_image_channels[0]);*/

		//将当前灰度图二值化
		//threshold(gray_image, gray_image_threshold, 30, 255, THRESH_BINARY);//将差值进行二值化。
		//imshow("当前ROI原图二值化图", gray_image_threshold);

		//注释掉即为背景侦察法。不注释就是帧差法。
		gray_image.copyTo(background);

		// 看膨胀后的效果
		//morphologyEx(rimage, gray_image_p, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(3, 3)));//膨胀  
		//imshow("膨胀后", gray_image_p);


		//开运算
		//morphologyEx(rimage, rimage, MORPH_ERODE, getStructuringElement(MORPH_RECT, Size(3, 3)));//腐蚀
		//morphologyEx(rimage, rimage, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  
		morphologyEx(rimage, rimage, MORPH_OPEN, getStructuringElement(MORPH_RECT, Size(5, 5)));//MORPH_DILATE MORPH_ERODE 5
		//morphologyEx(rimage, rimage, MORPH_CLOSE, getStructuringElement(MORPH_RECT, Size(5, 5)));//MORPH_DILATE MORPH_ERODE
		//morphologyEx(rimage, rimage, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));//膨胀  

		rimage.copyTo(f_image);
		
		findContours(f_image, contours, CV_RETR_EXTERNAL, CHAIN_APPROX_NONE, Point(0, 0));
		
		


		cout << "第" << num_frame_1 << "张图" << "找到" << contours.size() << "个轮廓" << endl;
		//筛选出最大的轮廓addWeighted

		for (int i = 0; i < contours.size(); i++)
		{
			if (contours[i].size()> maxcontours.size())
			{
				maxnum = i;
				maxcontours = contours[i];
			}
		}
		//用冒泡法进行排序
		/*for (int i = 0; i < maxcontours.size(); i++)
		{
		for (int j = i; j < maxcontours.size(); j++)
		{
		if (maxcontours[j].x>maxcontours[i].x)
		{
		int temp_value_x = maxcontours[i].x;
		maxcontours[j].x = maxcontours[i].x;
		maxcontours[i].x = temp_value_x;
		}
		if (maxcontours[j].y>maxcontours[i].y)
		{
		int temp_value_y = maxcontours[i].y;
		maxcontours[j].y = maxcontours[i].y;
		maxcontours[i].y = temp_value_y;
		}
		}
		}*/
		/*for (int ii = 0; ii < maxcontours.size(); ii++)
		{
		for (int jj = ii; jj < maxcontours.size(); jj++)
		{
		if (maxcontours[jj].x>maxcontours[ii].x)
		{
		int temp_value_x = maxcontours[ii].x;
		maxcontours[jj].x = maxcontours[ii].x;
		maxcontours[ii].x = temp_value_x;
		}
		if (maxcontours[jj].y>maxcontours[ii].y)
		{
		int temp_value_y = maxcontours[ii].y;
		maxcontours[jj].y = maxcontours[ii].y;
		maxcontours[ii].y = temp_value_y;
		}
		}
		}*/
		//CvRect rect = cvBoundingRect(maxcontours, 0);

		if (maxcontours.size() >50)
		{
			Rect_1 = boundingRect(maxcontours);
			//Rect_2 = fitEllipse(maxcontours);
			rectangle(roi_image, Rect_1, Scalar(0, 0, 255), 2, 8);
			//ellipse(roi_image, Rect_2, Scalar(0, 0, 255), 1, 8);
			//算出矩形的中心区域
			int x, y;
			x = Rect_1.x + (Rect_1.width / 2);
			y = Rect_1.y + (Rect_1.height / 2);
			cout << "中心坐标为:" << x << "  " << y << endl;
			////画出要进行颜色判断的区域
			//Rect Rect_2((Rect_1.x - (Rect_1.width / 2)), (Rect_1.y - (Rect_1.height / 2)), Rect_1.width * 2, Rect_1.height * 2);
			//rectangle(roi_image, Rect_2, Scalar(0, 0, 255), 2, 8);
			////定义变量
			//int Roi_Rows_j_start, Roi_Rows_j_end, Roi_Cols_i_start, Roi_Cols_i_end;
			////赋初值
			//Roi_Rows_j_start = Rect_2.y;
			//Roi_Rows_j_end = Rect_2.y + Rect_2.height;
			//Roi_Cols_i_start = Rect_2.x;
			//Roi_Cols_i_end = Rect_2.x + Rect_2.width;
			////判断是否超界
			//if (Rect_2.x < 0)
			//{
			//	Roi_Cols_i_start = 0;
			//}
			//if ((Rect_2.x + Rect_2.width)>rimage.cols)


			//for (int i = Rect_2.x; i <Rect_2.x + Rect_2.width; i++)
			//{
			//	uchar* rimage_data_2 = rimage.ptr<uchar>(i);//此时rimage已经二值化
			//	//三个颜色通道 取指针
			//	uchar* roi_image_data_red_2 = roi_image_channels[2].ptr<uchar>(i);
			//	uchar* roi_image_data_green_2 = roi_image_channels[1].ptr<uchar>(i);
			//	uchar* roi_image_data_blue_2 = roi_image_channels[0].ptr<uchar>(i);
			//	for (int j = Rect_2.y; j < Rect_2.y + Rect_2.height; j++)
			//	{
			//		//进行颜色判断
			//		/*if (roi_image_data_red_2[j]>(roi_image_data_green_2[j] * 2) && roi_image_data_red_2[j]>(roi_image_data_blue_2[j] * 2) && roi_image_data_red_2[j]>40)
			//		{
			//		rimage_data_2[j] = 255;

			//		}*/
			//	}
			//}
		}

		/*void rectangle(CV_IN_OUT Mat& img, Rect rec,
		const Scalar& color, int thickness = 1,
		int lineType = 8, int shift = 0);*/
		for (int i = 0; i < maxcontours.size(); i++)
		{
			//cout << maxcontours[i].x<< endl;
			Goal.x += maxcontours[i].x;
			Goal.y += maxcontours[i].y;

		}
		if (maxcontours.size() > 50)
		{
			cout << maxcontours.size() << endl;
			Goal.x /= maxcontours.size();
			Goal.y /= maxcontours.size();
			cout << "目标点的坐标为" << "X:" << Goal.x << "Y:" << Goal.y << endl;
			circle(roi_image, Goal, 50, Scalar(0, 0, 255), 5, 8);
		}
		else
		{
			cout << "未发现目标点" << endl;
		}




		num_frame_1++;

		//变量复位。
		Goal = { 0, 0 };
		maxnum = 0;
		maxcontours.clear();
		//显示帧率
		//t = ((double)getTickCount() - t) / getTickFrequency();
		fps = 1.0 / t;
		sprintf_s(str, "FPS:%5f", fps);
		putText(frame, str, Point(0, 30), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 255));

		imshow("原图", frame);
		imshow("处理区域", roi_image);
		imshow("结果", rimage);


		key = waitKey(30);
		//switch (key)
		//{
		///*case 'c':	sprintf_s(filename, "D://capture//min//%d.bmp", num_frame);
		//	imwrite(filename, roi_image);*/
		//	/*printf("第%d采集完成\n", num_frame);
		//	break;*/
		////case ' ':Start_flag = !Start_flag; Jizhong_flag = 0; break;
		//case 'b': biaoding_flag = !biaoding_flag; break;
		////case 'g': biaodingqiu_flag = !biaodingqiu_flag;

		//	/*break;*/


		//}

	}

	



}

void on_MouseHandle(int event, int x, int y, int flags, void* param)
{
	switch (event)
	{
		//左键按下消息
	case EVENT_LBUTTONDOWN:
	{
							  if (biaoding_flag == 0)
							  {
								  Rect_ROI.x = x;//记录起始点
								  Rect_ROI.y = y;//记录起始点
								  //biaoding_flag = 0;
							  }
							  //if (biaodingqiu_flag == 1)
							  //{
								 // Panduan_goal.x = x;//记录起始点
								 // Panduan_goal.y = y;//记录起始点
								 // biaodingqiu_flag = 0;
							  //}
	}
		break;
	}
}

